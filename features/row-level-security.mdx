---
title: 'Row level security'
description: 'Control data access at the row level for multi-tenant applications'
icon: 'shield-halved'
---

Row level security (RLS) allows you to control which rows of data users can access in your database. This is particularly useful for multi-tenant applications where different users should only see their own data, or for team-based access where users should only access data relevant to their department or role.

<Info>
Row level security is currently only supported for **Postgres databases**. If you need RLS support for other database dialects, please [contact us](mailto:support@basedash.com) to discuss your use case.
</Info>

## How it works

When a user in your Basedash workspace runs a query, Basedash automatically sets a session variable called `basedash.groups` that contains all the groups the user belongs to (comma-separated). You can then create policies on your Postgres database that reference this session variable to restrict which rows are returned.

<Info>
We will always set up the `basedash.groups` session variable for Postgres databases. It will be an empty string if the user making the query doesn't belong to any groups.
</Info>

Here's the basic flow:

1. You assign users to groups in Basedash (e.g., "Engineering", "Sales", "Support")
2. You create row-level security policies on your database tables
3. When a user runs a query, Basedash sets the `basedash.groups` session variable
4. Your database policies automatically filter the results based on the user's groups

The key advantage of this approach is that you maintain full control over your security policies at the database level, while Basedash simply provides the user context needed to enforce those policies.

## Setting up RLS in Basedash

Whenever a query is executed against a Postgres database, Basedash automatically sets the `basedash.groups` session variable with the user's group memberships.

To view the available groups that will be passed in the session variable:

1. Open the command menu (Cmd+K or Ctrl+K)
2. Navigate to your data source settings
3. Select "Row Level Security"
4. View the available group names that you can reference in your policies

## Creating policies on your database

To control data access, you need to create RLS policies directly on your Postgres database. These policies define which rows users can access based on their group membership.

<Warning>
When you enable row level security on a table in Postgres, it will **deny all access by default** until you create policies that explicitly grant access. Make sure to create the appropriate policies immediately after enabling RLS to avoid disrupting access to your data.
</Warning>

### Basic example

Here's a simple example for an `orders` table where you want to restrict access based on a `department` column:

```sql
-- Enable RLS on the table
ALTER TABLE orders ENABLE ROW LEVEL SECURITY;

-- Create a policy for SELECT operations
CREATE POLICY orders_group_policy ON orders
  FOR SELECT
  USING (
    current_setting('basedash.groups', true) IS NULL
    OR ',' || current_setting('basedash.groups', true) || ','
      LIKE '%,' || department || ',%'
  );
```

This policy allows:
- Normal access when `basedash.groups` is not set (so your existing applications continue to work)
- Filtered access when the session variable is set (Basedash queries)

### Multiple group membership

The policy pattern uses comma-separated values, so it automatically handles users who belong to multiple groups. For example, if a user belongs to both "Engineering" and "Support" groups, the `basedash.groups` variable will be set to `"Engineering,Support"`, and the policy will match rows where the department is either "Engineering" or "Support".

### Permissive policies for external systems

If you want to allow all operations from external systems (those not using Basedash), you can create permissive policies:

```sql
-- Allow external systems full access for INSERT, UPDATE, DELETE
CREATE POLICY orders_external_insert ON orders
  FOR INSERT
  WITH CHECK (current_setting('basedash.groups', true) IS NULL);

CREATE POLICY orders_external_update ON orders
  FOR UPDATE
  USING (current_setting('basedash.groups', true) IS NULL);

CREATE POLICY orders_external_delete ON orders
  FOR DELETE
  USING (current_setting('basedash.groups', true) IS NULL);
```

## Basedash Warehouse

If you're using Basedash Warehouse (our managed Postgres warehouse for Fivetran connections), you can create policies using the warehouse credentials.

To access your Basedash Warehouse credentials:

1. Open the command menu (Cmd+K or Ctrl+K)
2. Type "Basedash Warehouse"
3. Select "View credentials"
4. Use these credentials to connect to your warehouse and create policies

Note that you must have at least one Fivetran connection set up through Basedash Warehouse for this option to be available.

Once you have the credentials, you can connect to your warehouse using any Postgres client (like `psql`, pgAdmin, or TablePlus) and run the `CREATE POLICY` statements directly.

## RLS with chat

Row level security automatically applies to all queries in Basedash, including those generated through the AI chat interface. When users ask questions about their data in chat, the AI-generated SQL queries will respect your RLS policies, ensuring users only see data they're authorized to access.

![RLS in chat](/images/rls-chat.png)

This means your team members can freely explore and ask questions about data through natural language, while your database policies ensure they stay within their authorized scope.


## RLS with reports

When scheduled reports are executed, the `basedash.groups` session variable is set using the groups associated with the user who created the report. RLS policies are applied based on the report creator's group memberships.

However, there is currently a limitation where any user with access to a report can modify its prompt or context. This creates a potential loophole where users could modify a report created by someone with broader access to query data they wouldn't normally have access to. We are working on a solution to address this issue.

Until this is resolved, be aware that:

- Report queries use the creator's group memberships
- Users who can edit reports may be able to access data outside their own group permissions
- RLS policies are enforced, but based on the report creator's access rather than the report viewer's access

We are working on a way to limit who can edit report context once a report is created to remove this limitation.

## RLS with slack integration

When queries are executed through the Basedash Slackbot, we attempt to match the Slack user to their Basedash user account. If the match is successful, the `basedash.groups` session variable is set with the user's group memberships, and RLS policies are applied normally.

However, only the user who installed the Slack integration in Basedash can have their account linked to Slack. This means:

- **For the installing user**: When they trigger queries through the Slackbot, the `basedash.groups` session variable is set with their group memberships, and RLS policies are applied based on their access
- **For all other Slack users**: When they trigger the Basedash bot, they are not linked to any Basedash account, so:
  - The `basedash.groups` session variable will be set to an empty string
  - Tables with RLS policies that require group membership will return no rows
  - They will not be able to access any group-restricted data through Slack

We are looking to be able to reliably link all slack users to with Basedash users.

## Important considerations

### Database support

Row level security is currently supported for **Postgres databases only**. Support for other database systems may be added in the future. If you need RLS support for other database dialects, please [contact us](mailto:support@basedash.com) and let us know about your use case.

### Admin access outside Basedash

Admin users who have access to your database credentials (including Basedash Warehouse credentials) can connect to the database directly and query data without RLS restrictions. The policies only apply when the `basedash.groups` session variable is set, which only happens during Basedash queries.

If you need to ensure that all access to your database goes through RLS policies, you should use dedicated database users for external access and create policies that apply to those users as well.

### Compatibility with existing applications

The policy pattern shown above uses a NULL check (`current_setting('basedash.groups', true) IS NULL`) to ensure that your existing applications and services that query the database directly will continue to work normally without any restrictions. Only queries that come through Basedash (which set the session variable) will have the RLS policies applied.

### Performance

Row level security policies are evaluated for every query, so complex policies can impact query performance. Keep policies simple and ensure that any columns referenced in the policies are properly indexed.


## Best practices

1. **Start simple** - Begin with policies on a single table and test thoroughly before expanding to your entire database

2. **Use consistent column names** - If you're using RLS across multiple tables, use consistent column names (like `department` or `team_id`) to make policy management easier

3. **Test with different user groups** - Create test users in different groups and verify that they can only access the appropriate data

4. **Document your policies** - Keep track of which tables have RLS enabled and what the policies do, especially as your database schema grows

5. **Monitor query performance** - Watch for any performance degradation after enabling RLS, and optimize policies or add indexes as needed

